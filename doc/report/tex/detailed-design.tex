\section{Design di dettaglio}

Dopo aver descritto l’architettura del sistema si procede con il design di dettaglio delle sue componenti principali. 
L’approccio progettuale utilizzato combina aspetti Object-oriented, come l’utilizzo dell’interfaccia come astrazione attraverso la quale caratterizzare i componenti, per scatenare comportamenti diversi su entità soggette ad un comune contratto, con elementi di programmazione funzionale pura, quali la tendenza all’impiego di strutture dati immutabili e la riduzione di side effects, favorendo la descrizione lazy della computazione, la separazione fra componente strutturale e comportamentale delle entità ed altri elencati di seguito.


\subsection{Core}
Il motore della simulazione (simulationEngine) consiste in una descrizione monadica delle fasi della simulazione, che prevede l’aggiornamento dei parametri del mondo, il rilevamento e risoluzione delle collisioni fra le entità che lo popolano, la visualizzazione a video del suo stato aggiornato e l’attesa dell’intervallo di tempo prima della successiva iterazione. In questo modo il codice non contiene i side effects invece presenti in un’equivalente versione procedurale, e la parte non funzionalmente pura, ovvero quella non che rispetta le proprietà di trasparenza referenziale) è situata all’avvio della simulazione. 
Questo andamento sequenziale e periodico è stato modellato attraverso una composizione di State monad  (State[World, A]) (per quanto riguarda l’aggiornamento della struttura del mondo) e di IO monad (per le operazioni di I/O come il display a video delle entità e delle statistiche storiche alla chiusura dell’applicazione). Per tale motivo (e a fini di leggibilità sono stati definiti i seguenti type alias):


MISSING SNIPPET

La IO monad permette di esprimere una computazione in modo lazy, e in più, la State monad consente di rendere implicito il passaggio di stato aggiornato fra le operazioni sequenziali di manipolazione del mondo, ciascuna delle quali determina una sua nuova versione. Al fine di combinare 2 monadi differenti, che in quanto tali non si possono comporre fra di loro [cit. fpis], è stato utilizzato il Monad transformer StateT: (StateT[SimulationIO, World, A]).

MISSING SNIPPET

\subsection{Model}
\subsubsection{World}
Il World è stato modellato come un contenitore immutabile delle proprietà della simulazione e delle entità che vi partecipano. Al fine di memorizzare i dati necessari ai fini di analisi, esso è definito in termini di se stesso: la worldHistory è uno stream costituito dalle istanze di World riferite alle iterazioni precedenti. La lazy evaluation degli stream permette di non appesantire la computazione del simulationLoop con un carico di lavoro altrimenti insostenibile: impiegare una collezione non lazy come una lista avrebbe comportato la creazione di una moltitudine di strutture dati intermedie di grandissime dimensioni. 

MISSING World UML

Grazie agli stream, la valutazione della grande quantità di dati accumulata avviene solo alla conclusione della simulazione e al momento del processamento dei dati a fini statistici, non interferendo così con l’andamento della simulazione.

\subsubsection{Struttura entità}
Per la modellazione degli aspetti strutturali delle entità del World si è sfruttato il meccanismo dei self-type al fine di rendere modulare l’acquisizione di ogni singola caratteristica genetica della popolazione attraverso l’algoritmo di linearizzazione predisposto da scala. Una volta definiti, con un’ottica molto granulare, un set di proprietà e i self-type corrispondenti, attribuendo a ciascuno di essi un dominio minimale ed una singola proprietà / funzionalità, la definizione della componente strutturale delle entità richieste dai requisiti si riduce ad un’attività di composizione di moduli elementari. Ciò porta ad una struttura composta da più livelli di componenti, alcuni dei quali condivisi da più entità. Questo approccio rende riutilizzabili in futuro le astrazioni già definite permettendo di combinare i diversi tratti genetici con flessibilità.
Come proprietà della struttura sono utilizzati diversi parametri Higher Order (come Movement strategy, degradationEffect e collisionEffect), che fungono da strategie e definiscono il comportamento dell’entità per aspetti specifici (la degradazione della propria vita o il movimento all’interno dell’area di simulazione, ad esempio). Ciò permette di riutilizzare una stessa struttura per modellare una serie di comportamenti diversi, piuttosto che codificare tale diversità di comportamento nel codice, trasferendola dunque a livello di istanza anziché di classificazione (dall’aspetto intensionale a quello estensionale). Invece di esprimere nel codice di una entità la logica di alcuni aspetti specifici, si incapsula dunque tale gestione in un parametro higher order, permettendo di riutilizzare anche per entità con diverse logiche di degradazione (ad es.) la struttura rimanente. Al contempo, chiunque vorrà estendere il sistema di simulazione in futuro potrà usufruire di tali strategie per l’implementazione delle sue componenti.

\subsubsection{Comportamento entità}
L’aspetto comportamentale delle entità, che riguarda cioè le operazioni che agiscono sul loro stato in occasione dell’evento di aggiornamento del mondo e di collisione con altre entità, è gestito mediante 2 trait con self types: Updatable e COllidable. Questa modellazione prevede di sfruttare la interfaccia per variare il comportamento sotto la stessa astrazione e fornire estendibilità futura e, al contempo, un approccio funzionale nella gestione dello stato (ogni entità è immutabile e l’aggiornamento coincide con la generazione di una nuova versione con proprietà modificate). Le signature di Updatable e Collidable prevedono di restituire un set di SimulableEntity che rimpiazza l’entità nell’iterazione successiva e permette di esprimerne la rimozione, l’aggiornamento o eventi quali la riproduzione o la clonazione della stessa.
Il requisito che un’entità deve soddisfare per partecipare ad una simulazione si suddivide in 2 componenti, rappresentati dal type alias SimulableEntity: dal punto di vista strutturale il vincolo di rappresentare un’Entity, mentre, dal p. di vista comportamentale, quello di disporre di un’implementazione di tali 2 trait, la cui unione è definita mediante il type alias Simulable. 

MISSING SNIPPET

A tale scopo, i companion object di Collidable e Updatable forniscono delle implementazioni dei rispettivi trait pronte all’uso per comportamenti riusabili e applicabili intercambiabilmente a qualunque Entity. (NeutralUpdatable e NeutralCollidable definiscono dei comportamenti che decorano i tipi sottostanti non inducendo nessuna modifica nella entità su cui vengono installati). Per questo motivo, in ottica futura, l’implementazione di Entity è sufficiente a disporre di nuove entità potenzialmente integrabili all’interno della simulazione.


\subsection{View}

MANCANTE

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth, scale=0.44]{img/Model.png}
\caption{Design Model}
\label{fig:model}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth, scale=0.44]{img/ModelHierarchy.png}
\caption{Gerarchia Model}
\label{fig:modelhierarchy}
\end{figure}